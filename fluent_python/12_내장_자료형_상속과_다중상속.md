# 내장 자료형 상속과 다중 상속
- 이번 챕터에서 집중적으로 알아볼 내용 두 가지
  - 내장 자료형 상속의 위험성
  - 다중 상속과 메서드의 결정 순서
- 다중 상속은 장점 < 단점 으로 생각하는 사람이 많다.
  - java에 다중상속 없지만 문제 x
  - C++에서 다중상속으로 고통받은 사람 많음
- Tkinter GUI툴킷과 django를 통해 다중상속 설명해 드림.
- 먼저 내장 자료형 상속하는 문제부터 보자.
## 1. 내장 자료형의 상속은 까다롭다.
- C언어로 작성된 내장 클래스(예: dict, list, str)는 상속하지 않는걸 추천
- 왜냐면 사용자가 오버라이드한 코드를 호출하지 않기 때문에 에러 발생하기가 쉽다.
  
![스크린샷 2022-01-01 오후 12 06 29](https://user-images.githubusercontent.com/60768642/147843143-8423bcef-4aec-46b4-952e-137d1e9c4f1e.png)

![스크린샷 2022-01-01 오후 12 07 29](https://user-images.githubusercontent.com/60768642/147843166-9f92097f-b32c-4e16-affc-3535f2548f75.png)

- c언어로 된 내장 클래스가 아닌 파이썬으로 작성된 collections의 UserDict, UserList, UserString을 상속받는 것을 추천한다.
``` 
class DoppeDict2(collections.UserDict):
    def __setitem__(self, key, value):
        super().__setitem__(key, [value] * 2)

class AnswerDict2(collections.UserDict):
    def __getitem__(self, key):
        return 42
```

## 2. 다중 상속과 메서드 결정 순서
- 다중 상속시 서로 다른 부모 클래스에서 같은 이름의 메서드를 구현했다면? -> 소위 '다이아몬드 문제'
``` 
class A:
    def ping(self):
        print("ping", self)


class B(A):
    def pong(self):
        print("pong", self)


class C(A):
    def pong(self):
        print("PONG", self)


class D(B, C):
    def ping(self):
        super.ping()
        print('post-ping:', self)

    def pingpong(self):
        self.ping()
        super.ping()
        self.pong()
        super().pong()
        C.pong(self)

```

![스크린샷 2022-01-01 오후 12 14 11](https://user-images.githubusercontent.com/60768642/147843239-14fec23c-579d-4c9f-ae88-d1b54aa965f3.png)

![스크린샷 2022-01-01 오후 12 16 51](https://user-images.githubusercontent.com/60768642/147843261-920142af-c2c3-4643-940a-475e720f6ada.png)

![스크린샷 2022-01-01 오후 12 17 04](https://user-images.githubusercontent.com/60768642/147843263-13687885-becd-41ef-a17a-1d8f6b4e5fcb.png)
- mro: Method Resolution Order

- MRO를 우회해서 슈퍼클래스를 직접 호출할 수도 있다.(때로는 이 방법이 더 편리함) 아래 예시 참고.
- 참고로 메서드를 클래스에서 직접 호출할 때는 self를 넘겨줘야 한다. **바인딩되지 않은 메서드**에 접근하는 것이기 때문
```
def ping(self):
    A.ping(self)
    print('post-ping:', self)
```
- 하지만 프레임워크처럼 직접 제어할 수 없는 메서드를 호추할 때는 super()를 사용하는 것이 안전.
#### 이상한 점
```
d = D()
d.pingpong()
```
- 왜 위코드를 호출하면 아래 에러가 날까? 이상하네
- `AttributeError: type object 'super' has no attribute 'ping'`
## 3. 실세계에서의 다중 상속
- 어댑터 패턴이 다중상속 사용함.
- tkinter예시
## 4. 다중 상속 다루기
### 1. 인터페이스 상속과 구현 상속을 구분한다
- 다중상속 시 상속 이유를 명확히 하는 것이 좋다. 상속 이유는 주로 아래 두개다.
  - 인터페이스 상속은 'is-a'관계를 의미하는 서브타입을 생성한다.
  - 구현 상속은 재사용을 통해 코드 중복을 피한다.
- 실제론 이 두 가지 목적을 모두 가진 경우가 많지만, 의도를 명확히 할 수있을 때는 명백히 표현하는 것이 좋다.
- 코드 재사용을 위한 상속은 구현에 관련된 것이며, composition이나 위임(?) 으로 대체할 수 있는 경우도 종종 있다.
- 한편 인터페이스 상속은 프레임워크에서 중추적인 역할을 수행한다.
### 2. ABC를 이용해서 인터페이스를 명확히 한다.
### 3. 코드를 재사용하기 위해 믹스인을 사용한다.
- 'is-a' 관계도 아니고, 서로 관련 없는 여러 서브클래스를 재사용하기 위해 설계된 클래스는 명시적으로 믹스인 클래스로 만들어야 한다.
- 믹스인은 개념적으로 새로운 자료형을 정의하지 않고, 단지 재사용할 메서드들을 묶어놓을 뿐이다.
- 믹스인 클래스로 객체럴 생성하면 안되고, 믹스인 클래스를 상속하는 구상 클래스는 다른 클래스도 상속해야 한다.
- 믹스인 클래스는 밀접히 연관된 메서드 몇 개를 구현해서 하나의 구체적인 행위를 제공해야 한다.
### 4. 이름을 통해 믹스인임을 명확히 한다.
- 클래스명 뒤에 Mixin을 붙여라!
### 5. ABC가 믹스인이 될 수 있지만, 믹스인이라고 해서 ABC인 것은 아니다.
- ABC는 구상 메서드를 구현할 수 있으므로 믹스인으로 사용할 수도 있다.
- ABC는 자료형을 정의하지만, 믹스인은 자료형을 정의하지 않는다.
- ABC는 다른 클래스의 유일한 기저 클래스가 될 수 있는 반면, 믹스인은 하나만 새용해서 서브클래스를 정의하면 안된다(드물게 예외도 있음)
- ABC에만 적용되는 제한: ABC에서 구현된 구상 메서드는 해당 ABC나 슈퍼클래스의 메서드만 사용할 수 있다. 즉,  
ABC에 정의된 구상 메서드는 일종의 편의를 위한 것일 뿐이다.  
구상 메서드가 수행하는 모든 것은 ABC의 다른 메서드를 호출해서동일하게 수행할 수 있기 때문이다.
### 6. 두 개 이상의 구상 클래스에서 상속받지 않는다.
- 구상 클래스는 0개, 많아야 하나의 구상 슈퍼클래스를 가져야 한다.
- 즉 구상 클래스의 슈퍼클래스 중 하나를 제외한 나머지 클래스는 ABC나 믹스인이어야 한다.
- (구상 슈퍼클래스가 정확히 뭘까?)
### 7. 사용자에게 집합 클래스를 제공한다.
- ABC, 믹스인을 조합해서 호출 코드에 유용한 기능을 제공할 때는, 이들을 적절히 통합하는 클래스를 제공하는 것이 좋다.
- 예시: 장고의 ListView
- 아래 예시처럼, 내용은 비었지만 상속만 받아놓은 게 그 예시다.
- 이걸 사용하는 개발자는 저 모든 상속관계를 기억할 필요 없이 편하게 가져다 쓰면 된다.
```
class Widget(BaseWidget, Pack, Place, Grid):
    pass
```
### 8. 클래스 상속보다 객체 구성을 사용하라
- composition > inheritance 가 융통성이 더 높음.

## 5. 최신 사례: 장고 GenericView의 Mixin
- 책 참고
## 6. 요약
