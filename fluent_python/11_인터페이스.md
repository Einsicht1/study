# 인터페이스: 프로토콜에서 ABC까지
> 추상클래스는 인터페이스를 표현한다 - 비야네 스트롭스트룹(C++의 창시자)

## 1. 파이썬 문화에서의 인터페이스와 프로토콜
- 프로토콜은 파이썬과 같은 동적 자료형을 제공하는 언어에서 다형성을 제공하는 비공식 인터페이스다.
- 파이썬에는 interface라는 키워드는 없다.
- 하지만 모든 클래스는 인터페이스를 가지고 있다.
- 클래스가 상속, 구현한 공개 속성(메서드, 데이터)들의 집합이 인터페이스다.
  - `__getitem__(), __add__()`같은 magic method또한 인터페이스다.
- 스몰토크에서는 어떤 역할을 완수하기 위한 메서드 집합으로서의 인터페이스를 **프토코콜**이라 불렀다.
- 다른 동적 언어 커뮤니티에도 이 용어가 퍼졌다.
- 프로토콜: 인터페이스지만 비공식적. 공식 인터페이스처럼 강제할 수 없다.
## 2. 파이썬은 시퀀스를 찾아낸다
- **시퀀스 프로토콜**은 파이썬에서 가장 핵심적인 인터페이스 중 하나다.
- python data model은 가능한 한 많이 핵심 프로토콜과 협업하겠다는 철학을 가지고 있다.
- 아래 클래스는 `__len__(), __contains__(), __iter__()`를 구현하지 않았지만, 반복, in연산 등이 가능하다.
- 파이썬은 약간이라도 sequence를 닮은 객체는 모두 특별하게 처리하기 때문.
- -> 프로토콜의 동적인 성질을 잘 보여주는 예
```
class Foo:
  def __getitem__(self, pos):
  return range(0, 30, 10)[pos]


>>> f[1]
10
>>> f = Foo()
>>> for i in f: print(i) ...
0
10
20
>>>20 in f
True
>>>15 in f
False
```
## 3. 런타임에 프로토콜을 구현하는 멍키 패칭
- 멍키 패칭: 소스 코드를 건드리지 않고 런타임에 클래스, 모듈을 변경하는 행위
- 아래 예시는 멍키패칭, 프로토콜이 동적이라는 특성을 보여준다.

![스크린샷 2021-12-31 오후 6 27 56](https://user-images.githubusercontent.com/60768642/147815190-ae624d39-320c-43a3-ad2c-df0949fbd154.png)
![스크린샷 2021-12-31 오후 6 28 06](https://user-images.githubusercontent.com/60768642/147815193-2a4e1231-2e54-4f4c-b98e-4c07d421e990.png)
![스크린샷 2021-12-31 오후 6 28 09](https://user-images.githubusercontent.com/60768642/147815195-e5342243-464a-4f40-9ab9-1382f8547108.png)

- 처음에 FrenchDeck클래스는 불변 시퀀스 프로토콜만 구현함
- 가변 시퀀스는 `__setitem__()` 메서드를 지원해야 하기 때문에 이를 멍키패칭으로 동적으로 구현
> random.shuffle()함수는 자신이 받는 인수의 자료형에 대해 신경쓰지 않는다.  
단지 받은 객체가 일부 가변 시퀀스 프로토콜을 구현하고 있으면 될 뿐이다.
심지어 해당 객체가 필요한 메서드를 '원래부터' 가지고 있었는지, 아니면 나중에 얻었는지는 전혀 문제가 되지 않는다.
- 지금까지 알아본 것은 '덕 타이핑'

## 4. 알렉스 마르텔리의 물새
> 덕 타이핑은 객체의 실제 자료형은 무시하고, 대신 객체가 용도에 맞는 메서드 이름, 시그너처, 의미를 구현하도록 보장하는 데 주안점을 둔다.  
> 파이썬에서는 결국 자료형 검사를 위한 isinstance() 함수의 회피를 의미한다....  
> 고전적인 덕 타이핑을...구스 타이핑으로 보완하고자 한다.(완전 대체 x)  
> **구스 타이핑** 이라는 말은 cls가 추상 베이스 클래스인 경우, 즉 cls의 메타클래스가 abc.ABCMeta인 경우에는 isinstance(obj, cls)를 써도 좋다는 것을 의미한다.  
> 초고수 파이썬 개발자가 아니라면 직접 ABC를 정의하지 말아라.

![스크린샷 2021-12-31 오후 6 37 14](https://user-images.githubusercontent.com/60768642/147815667-80e3ca72-84e9-493c-86d1-29b2b0df02d0.png)
> `__len__()`만 구현하면 abc.Sized의 서브클래스가 된다.
> 정리: numbers, collections.abc, 혹은 여러분이 사용할 다른 프레임워크에 있는 ABC가 표현하는 개념을 실현하는 클래스를 구현할 때는  
> 언제나 해당 ABC를 상속하거나 해당 ABC에 등록해라(직접 만들지 말아라)
> 배포용 코드에 절대로 ABC나 메타클래스를 직접 구현하지 말라.(멋진 망치를 새로 장만한 사람에게 모든 문제가 못으로 보이는 증세)

- but ABC를 사용하더라고 isinstance()를 떡칠하면 code smell(악취)다.
- if/elif로 isinstance()를 검사하는 건 좋지 않다. 
- 위 경우엔 다형성을 사용해야 한다.(인터프리터가 적절한 메서들르 호출할 수 있게 구현해라) -> **예를 든다면..?**
- 아래는 덕타이핑 예시
```
try:
    field_names = field_names.replace(',', ' ').split()
except AttributeError: 
    pass
field_names = tuple(field_names)
```
- 아래 챕터부터는 구스타이핑의 시작
## 5. ABC 상속하기
- MutableSequence를 상속했으므로 `__delitem__(), insert()`를 구현해야 한다.
- 파이썬은 모듈을 로딩하거나 컴파일할 때가 아닌, 실행 도중 실제 객체를 생성할 때 추상 메서드 구현 여부를 확인한다.
- 이때 구현x면 TypeError발생한다.
- 따라서 `__delitem__(), insert()`를 구현해야 한다.
![스크린샷 2021-12-31 오후 6 44 24](https://user-images.githubusercontent.com/60768642/147816074-3ebd3966-4016-4c77-8d4e-b83388ac7926.png)
![스크린샷 2021-12-31 오후 6 44 31](https://user-images.githubusercontent.com/60768642/147816076-907548bb-6292-4fba-82d6-f94cf47b1c70.png)

## 6. 표준 라이브러리의 ABC
### 6-1collections.abc의 ABC
### 6-2. ABC의 숫자탑    
## 7. ABC의 정의와 사용
> 추상 메서드도 실제 구현 코드를 가질 수 있다. 추상 메서드가 실제 구현 메서드를 담고 있더라도  
> 서브클래스는 이 메서드를 오버라이드해야 한다.  
> 하지만 서브클래스에서는 처음부터 모든 기능을 구현하는 대신 super()를 이용해서  
> 추상 메서드가 구현한 기능을 재사용할 수 있다.
### 7-1. ABC의 상세 구문
- ABC를 선언할 때는 abc.ABC나 다른 ABC를 상속하는 방법이 가장 좋다.
> 일반적으로 누적된 함수 데코데이터의 순서는 중요하다.  
> abstractmethod()를 다른 메서드 디스크립터와 함께  적용할 때는 이 데코레이터를 제일 안쪽에 위치시켜야 한다.


### 7-2. Tombola ABC 상속하기
### 7-3. Tombola의 가상 서브클래스
## 8. Tombola 서브클래스 테스트 방법
## 9. register()의 실제 용법
## 10. 오리처럼 행동할 수 있는 거위
## 11. 요약
> ABC가 쉽게 자료형을 검사할 수 있게 해주지만,  
> 프로그램에서 ABC를 남용해서는 안된다.  
> 파이썬은 상당히 많은 융통성을 부여하는 동적 언어라는 철학을 기반으로 하고 있다.  
> 모든 곳에서 자료형을 통제하려고 하면 필요 이상으로 복잡한 코드가 나온다.  
> 파이썬의 융통성을 받아들이기 바란다.
